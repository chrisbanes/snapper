{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Snapper is a library which brings snapping to the Compose scrolling layouts (currently LazyColumn and LazyRow): Sample app Your browser does not support the video tag. Tivi Your browser does not support the video tag. The basic usage looks like so: val lazyListState = rememberLazyListState () LazyRow ( state = lazyListState , flingBehavior = rememberSnapperFlingBehavior ( lazyListState ), ) { // content } API Summary \u00b6 The API is generally split into a few things: SnapperFlingBehavior , which is what apps provide to scrollable containers. A number of remember functions allowing easy use of SnapperFlingBehavior from composables. SnapperFlingLayoutInfo , which is an facade class allowing SnapperFlingBehavior to interact with different scrollable container state in a generic way. Implementations of SnapperFlingLayoutInfo for easy integration, such as LazyListFlingLayoutInfo . For examples, refer to the samples . Download \u00b6 repositories { mavenCentral () } dependencies { implementation \"dev.chrisbanes.snapper:snapper:<version>\" } Snapshots of the development version are available in Sonatype's snapshots repository . These are updated on every commit. License \u00b6 Copyright 2021 Chris Banes Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at https://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"Overview"},{"location":"#api-summary","text":"The API is generally split into a few things: SnapperFlingBehavior , which is what apps provide to scrollable containers. A number of remember functions allowing easy use of SnapperFlingBehavior from composables. SnapperFlingLayoutInfo , which is an facade class allowing SnapperFlingBehavior to interact with different scrollable container state in a generic way. Implementations of SnapperFlingLayoutInfo for easy integration, such as LazyListFlingLayoutInfo . For examples, refer to the samples .","title":"API Summary"},{"location":"#download","text":"repositories { mavenCentral () } dependencies { implementation \"dev.chrisbanes.snapper:snapper:<version>\" } Snapshots of the development version are available in Sonatype's snapshots repository . These are updated on every commit.","title":"Download"},{"location":"#license","text":"Copyright 2021 Chris Banes Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at https://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"usage/","text":"Snap positions \u00b6 Snapper supports the customization of where items snap to. By default Snapper will snap items to the center of the layout container, but you can provide your own 'snap offset' via the snapOffsetForItem parameters. snapOffsetForItem is a parameter which takes a block in the form of (layoutInfo: SnapperLayoutInfo, item: SnapperLayoutItemInfo) -> Int , and allows apps to supply custom logic of where to snap each individual item. A number of predefined values are supplied in the SnapOffsets class, for snapping items to the start, center and end. LazyRow ( state = lazyListState , flingBehavior = rememberSnapperFlingBehavior ( lazyListState = lazyListState , snapOffsetForItem = SnapOffsets . Start , ), ) { // content } Finding the 'current' item \u00b6 Most of the time apps will probably use the short-hand convenience function: rememberSnapperFlingBehavior(LazyListState) , but there are times when it is useful to get access to the SnapperLayoutInfo . SnapperLayoutInfo provides lots of information about the 'snapping state' of the scrollable container, and provides access to the 'current item'. For example, if you wish to invoke some action when a fling + snap has finished you can do the following: val lazyListState = rememberLazyListState () val layoutInfo = rememberLazyListSnapperLayoutInfo ( lazyListState ) LaunchedEffect ( lazyListState . isScrollInProgress ) { if ( ! lazyListState . isScrollInProgress ) { // The scroll (fling) has finished, get the current item and // do something with it! val snappedItem = layoutInfo . currentItem // TODO: do something with snappedItem } } LazyColumn ( state = lazyListState , flingBehavior = rememberSnapperFlingBehavior ( layoutInfo ), ) { // content } Customization of the target index \u00b6 The snapIndex parameter allows customization of the index which Snapper which fling to after a user has started a fling. The block is given the SnapperLayoutInfo , the index where the fling started, and with the index which Snapper has determined is the correct index to fling, without the layout limits. The block should return the index which Snapper should fling and snap to. The following are some examples of what you can achieve with snapIndex . Controlling the maximum fling distance \u00b6 The following example sets the snapIndex so that the user can only fling up a maximum of 3 items: val MaxItemFling = 3 LazyRow ( state = lazyListState , flingBehavior = rememberSnapperFlingBehavior ( lazyListState = lazyListState , snapIndex = { layoutInfo , startIndex , targetIndex -> targetIndex . coerceIn ( startIndex - MaxItemFling , startIndex + MaxItemFling ) } ), ) { // content } Snapping groups \u00b6 The snapIndex parameter can also be used to achieve snapping to 'groups' of items. The following example provide a snapIndex block which snaps flings to groups of 3 items: val GroupSize = 3 LazyRow ( state = lazyListState , flingBehavior = rememberSnapperFlingBehavior ( lazyListState = lazyListState , snapIndex = { _ , _ , targetIndex -> val mod = targetIndex % GroupSize if ( mod > ( GroupSize / 2 )) { // Round up towards infinity GroupSize + targetIndex - mod } else { // Round down towards zero targetIndex - mod } ), ) { // content } Animation specs \u00b6 SnapperFlingBehavior allows setting of two different animation specs: decayAnimationSpec and springAnimationSpec . decayAnimationSpec is the main spec used for flinging, and is used when the fling has enough velocity to scroll past the current item. springAnimationSpec is used when there is not enough velocity to fling using decayAnimationSpec , and instead 'snaps' to the current item. Both of the specs can be customized to apps wishes.","title":"Usage"},{"location":"usage/#snap-positions","text":"Snapper supports the customization of where items snap to. By default Snapper will snap items to the center of the layout container, but you can provide your own 'snap offset' via the snapOffsetForItem parameters. snapOffsetForItem is a parameter which takes a block in the form of (layoutInfo: SnapperLayoutInfo, item: SnapperLayoutItemInfo) -> Int , and allows apps to supply custom logic of where to snap each individual item. A number of predefined values are supplied in the SnapOffsets class, for snapping items to the start, center and end. LazyRow ( state = lazyListState , flingBehavior = rememberSnapperFlingBehavior ( lazyListState = lazyListState , snapOffsetForItem = SnapOffsets . Start , ), ) { // content }","title":"Snap positions"},{"location":"usage/#finding-the-current-item","text":"Most of the time apps will probably use the short-hand convenience function: rememberSnapperFlingBehavior(LazyListState) , but there are times when it is useful to get access to the SnapperLayoutInfo . SnapperLayoutInfo provides lots of information about the 'snapping state' of the scrollable container, and provides access to the 'current item'. For example, if you wish to invoke some action when a fling + snap has finished you can do the following: val lazyListState = rememberLazyListState () val layoutInfo = rememberLazyListSnapperLayoutInfo ( lazyListState ) LaunchedEffect ( lazyListState . isScrollInProgress ) { if ( ! lazyListState . isScrollInProgress ) { // The scroll (fling) has finished, get the current item and // do something with it! val snappedItem = layoutInfo . currentItem // TODO: do something with snappedItem } } LazyColumn ( state = lazyListState , flingBehavior = rememberSnapperFlingBehavior ( layoutInfo ), ) { // content }","title":"Finding the 'current' item"},{"location":"usage/#customization-of-the-target-index","text":"The snapIndex parameter allows customization of the index which Snapper which fling to after a user has started a fling. The block is given the SnapperLayoutInfo , the index where the fling started, and with the index which Snapper has determined is the correct index to fling, without the layout limits. The block should return the index which Snapper should fling and snap to. The following are some examples of what you can achieve with snapIndex .","title":"Customization of the target index"},{"location":"usage/#controlling-the-maximum-fling-distance","text":"The following example sets the snapIndex so that the user can only fling up a maximum of 3 items: val MaxItemFling = 3 LazyRow ( state = lazyListState , flingBehavior = rememberSnapperFlingBehavior ( lazyListState = lazyListState , snapIndex = { layoutInfo , startIndex , targetIndex -> targetIndex . coerceIn ( startIndex - MaxItemFling , startIndex + MaxItemFling ) } ), ) { // content }","title":"Controlling the maximum fling distance"},{"location":"usage/#snapping-groups","text":"The snapIndex parameter can also be used to achieve snapping to 'groups' of items. The following example provide a snapIndex block which snaps flings to groups of 3 items: val GroupSize = 3 LazyRow ( state = lazyListState , flingBehavior = rememberSnapperFlingBehavior ( lazyListState = lazyListState , snapIndex = { _ , _ , targetIndex -> val mod = targetIndex % GroupSize if ( mod > ( GroupSize / 2 )) { // Round up towards infinity GroupSize + targetIndex - mod } else { // Round down towards zero targetIndex - mod } ), ) { // content }","title":"Snapping groups"},{"location":"usage/#animation-specs","text":"SnapperFlingBehavior allows setting of two different animation specs: decayAnimationSpec and springAnimationSpec . decayAnimationSpec is the main spec used for flinging, and is used when the fling has enough velocity to scroll past the current item. springAnimationSpec is used when there is not enough velocity to fling using decayAnimationSpec , and instead 'snaps' to the current item. Both of the specs can be customized to apps wishes.","title":"Animation specs"},{"location":"using-snapshot-version/","text":"Using a Snapshot Version of the Library \u00b6 If you would like to depend on the cutting edge version of the Snapper library, you can use the snapshot versions that are published to Sonatype OSSRH 's snapshot repository. These are updated on every commit to main . To do so: repositories { // ... maven { url 'https://oss.sonatype.org/content/repositories/snapshots' } } dependencies { // Check the latest SNAPSHOT version from the link above classpath 'dev.chrisbanes.snapper:snapper:XXX-SNAPSHOT' } You might see a number of different versioned snapshots. If we use an example: 0.3.0-SNAPSHOT is a build from the main branch, and depends on the latest tagged Jetpack Compose release (i.e. alpha03 ). 0.3.0.compose-6574163-SNAPSHOT is a build from the snapshot branch. This depends on the SNAPSHOT build of Jetpack Compose from build 6574163 . You should only use these if you are using Jetpack Compose snapshot versions (see below). Using Jetpack Compose Snapshots \u00b6 If you're using SNAPSHOT versions of the androidx.compose libraries, you might run into issues with the current stable release forcing an older version of those libraries. We publish snapshot versions of the library which depend on recent Jetpack Compose SNAPSHOT repositories. To find a recent build, look through the snapshot repository for any versions in the scheme x.x.x.compose-YYYY-SNAPSHOT (for example: 0.3.0.compose-6574163-SNAPSHOT ). The YYYY in the scheme is the snapshot build being used from AndroidX (from the example: build 6574163 ). You can then use it like so: repositories { // ... maven { url 'https://oss.sonatype.org/content/repositories/snapshots' } } dependencies { // Check the latest SNAPSHOT version from the link above classpath 'dev.chrisbanes.snapper:snapper:XXXX.compose-YYYYY-SNAPSHOT' } These builds are updated regularly, but there's no guarantee that we will create one for a given snapshot number. Note: you might also see versions in the scheme x.x.x.ui-YYYY-SNAPSHOT . These are the same, just using an older suffix.","title":"Using a Snapshot Version of the Library"},{"location":"using-snapshot-version/#using-a-snapshot-version-of-the-library","text":"If you would like to depend on the cutting edge version of the Snapper library, you can use the snapshot versions that are published to Sonatype OSSRH 's snapshot repository. These are updated on every commit to main . To do so: repositories { // ... maven { url 'https://oss.sonatype.org/content/repositories/snapshots' } } dependencies { // Check the latest SNAPSHOT version from the link above classpath 'dev.chrisbanes.snapper:snapper:XXX-SNAPSHOT' } You might see a number of different versioned snapshots. If we use an example: 0.3.0-SNAPSHOT is a build from the main branch, and depends on the latest tagged Jetpack Compose release (i.e. alpha03 ). 0.3.0.compose-6574163-SNAPSHOT is a build from the snapshot branch. This depends on the SNAPSHOT build of Jetpack Compose from build 6574163 . You should only use these if you are using Jetpack Compose snapshot versions (see below).","title":"Using a Snapshot Version of the Library"},{"location":"using-snapshot-version/#using-jetpack-compose-snapshots","text":"If you're using SNAPSHOT versions of the androidx.compose libraries, you might run into issues with the current stable release forcing an older version of those libraries. We publish snapshot versions of the library which depend on recent Jetpack Compose SNAPSHOT repositories. To find a recent build, look through the snapshot repository for any versions in the scheme x.x.x.compose-YYYY-SNAPSHOT (for example: 0.3.0.compose-6574163-SNAPSHOT ). The YYYY in the scheme is the snapshot build being used from AndroidX (from the example: build 6574163 ). You can then use it like so: repositories { // ... maven { url 'https://oss.sonatype.org/content/repositories/snapshots' } } dependencies { // Check the latest SNAPSHOT version from the link above classpath 'dev.chrisbanes.snapper:snapper:XXXX.compose-YYYYY-SNAPSHOT' } These builds are updated regularly, but there's no guarantee that we will create one for a given snapshot number. Note: you might also see versions in the scheme x.x.x.ui-YYYY-SNAPSHOT . These are the same, just using an older suffix.","title":"Using Jetpack Compose Snapshots"}]}