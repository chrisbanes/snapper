{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Snapper is a library which brings snapping to the Compose scrolling layouts (currently LazyColumn and LazyRow): Sample app Your browser does not support the video tag. Tivi Your browser does not support the video tag. The basic usage looks like so: val lazyListState = rememberLazyListState () LazyRow ( state = lazyListState , flingBehavior = rememberSnapperFlingBehavior ( lazyListState ), ) { // content } API Summary \u00b6 The API is generally split into a few things: SnapperFlingBehavior , which is what apps provide to scrollable containers. A number of remember functions allowing easy use of SnapperFlingBehavior from composables. SnapperFlingLayoutInfo , which is an facade class allowing SnapperFlingBehavior to interact with different scrollable container state in a generic way. Implementations of SnapperFlingLayoutInfo for easy integration, such as LazyListFlingLayoutInfo . For examples, refer to the samples . Download \u00b6 repositories { mavenCentral () } dependencies { implementation \"dev.chrisbanes.snapper:snapper:<version>\" } Snapshots of the development version are available in Sonatype's snapshots repository . These are updated on every commit. License \u00b6 Copyright 2021 Chris Banes Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at https://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"Overview"},{"location":"#api-summary","text":"The API is generally split into a few things: SnapperFlingBehavior , which is what apps provide to scrollable containers. A number of remember functions allowing easy use of SnapperFlingBehavior from composables. SnapperFlingLayoutInfo , which is an facade class allowing SnapperFlingBehavior to interact with different scrollable container state in a generic way. Implementations of SnapperFlingLayoutInfo for easy integration, such as LazyListFlingLayoutInfo . For examples, refer to the samples .","title":"API Summary"},{"location":"#download","text":"repositories { mavenCentral () } dependencies { implementation \"dev.chrisbanes.snapper:snapper:<version>\" } Snapshots of the development version are available in Sonatype's snapshots repository . These are updated on every commit.","title":"Download"},{"location":"#license","text":"Copyright 2021 Chris Banes Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at https://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"usage/","text":"Snap positions \u00b6 Snapper supports the customization of where items snap to. By default Snapper will snap items to the center of the layout container, but you can provide your own 'snap offset' via the snapOffsetForItem parameters. snapOffsetForItem is a parameter which takes a block in the form of (layoutInfo: SnapperLayoutInfo, item: SnapperLayoutItemInfo) -> Int , and allows apps to supply custom logic of where to snap each individual item. A number of predefined values are supplied in the SnapOffsets class, for snapping items to the start, center and end. LazyRow ( state = lazyListState , flingBehavior = rememberSnapperFlingBehavior ( lazyListState = lazyListState , snapOffsetForItem = SnapOffsets . Start , ), ) { // content } Content padding \u00b6 When setting content padding on LazyRow or LazyColumn it is important to supply that information to Snapper. Unfortunately LazyListState does not currently supply enough information for Snapper to calculate the scrollable region of the container, which is needed for the SnapOffsets feature above. We workaround this by apps supplying the the scrollable direction 'end' content padding which is being used, via the endContentPadding parameter. LazyRow val lazyListState = rememberLazyListState () val contentPadding = PaddingValues (...) LazyRow ( state = lazyListState , flingBehavior = rememberSnapperFlingBehavior ( lazyListState = lazyListState , // We need to provide the unresolved end value, so use Ltr endContentPadding = contentPadding . calculateEndPadding ( LayoutDirection . Ltr ), ), contentPadding = contentPadding , ) { // content } LazyColumn val lazyListState = rememberLazyListState () val contentPadding = PaddingValues (...) LazyColumn ( state = lazyListState , flingBehavior = rememberSnapperFlingBehavior ( lazyListState = lazyListState , endContentPadding = contentPadding . calculateBottomPadding (), ), contentPadding = contentPadding , ) { // content } Finding the 'current' item \u00b6 Most of the time apps will probably use the short-hand convenience function: rememberSnapperFlingBehavior(LazyListState) , but there are times when it is useful to get access to the SnapperLayoutInfo . SnapperLayoutInfo provides lots of information about the 'snapping state' of the scrollable container, and provides access to the 'current item'. For example, if you wish to invoke some action when a fling + snap has finished you can do the following: val lazyListState = rememberLazyListState () val layoutInfo = rememberLazyListSnapperLayoutInfo ( lazyListState ) LaunchedEffect ( lazyListState . isScrollInProgress ) { if ( ! lazyListState . isScrollInProgress ) { // The scroll (fling) has finished, get the current item and // do something with it! val snappedItem = layoutInfo . currentItem // TODO: do something with snappedItem } } LazyColumn ( state = lazyListState , flingBehavior = rememberSnapperFlingBehavior ( layoutInfo ), ) { // content } Controlling the maximum fling distance \u00b6 The maximumFlingDistance parameter allows customization of the maximum distance that a user can fling (and snap to). Apps can provide a block which will be called once a fling has been started. The block is given the SnapperLayoutInfo , if it needs to use the layout to determine the distance. The following example sets the maximum fling distance to 3x the container width. LazyRow ( state = lazyListState , flingBehavior = rememberSnapperFlingBehavior ( lazyListState = lazyListState , maximumFlingDistance = { layoutInfo -> val scrollLength = layoutInfo . endScrollOffset - layoutInfo . startScrollOffset // Allow the user to scroll 3x the LazyRow 'width' scrollLength * 3f } ), ) { // content } Animation specs \u00b6 SnapperFlingBehavior allows setting of two different animation specs: decayAnimationSpec and springAnimationSpec . decayAnimationSpec is the main spec used for flinging, and is used when the fling has enough velocity to scroll past the current item. springAnimationSpec is used when there is not enough velocity to fling using decayAnimationSpec , and instead 'snaps' to the current item. Both of the specs can be customized to apps wishes.","title":"Usage"},{"location":"usage/#snap-positions","text":"Snapper supports the customization of where items snap to. By default Snapper will snap items to the center of the layout container, but you can provide your own 'snap offset' via the snapOffsetForItem parameters. snapOffsetForItem is a parameter which takes a block in the form of (layoutInfo: SnapperLayoutInfo, item: SnapperLayoutItemInfo) -> Int , and allows apps to supply custom logic of where to snap each individual item. A number of predefined values are supplied in the SnapOffsets class, for snapping items to the start, center and end. LazyRow ( state = lazyListState , flingBehavior = rememberSnapperFlingBehavior ( lazyListState = lazyListState , snapOffsetForItem = SnapOffsets . Start , ), ) { // content }","title":"Snap positions"},{"location":"usage/#content-padding","text":"When setting content padding on LazyRow or LazyColumn it is important to supply that information to Snapper. Unfortunately LazyListState does not currently supply enough information for Snapper to calculate the scrollable region of the container, which is needed for the SnapOffsets feature above. We workaround this by apps supplying the the scrollable direction 'end' content padding which is being used, via the endContentPadding parameter. LazyRow val lazyListState = rememberLazyListState () val contentPadding = PaddingValues (...) LazyRow ( state = lazyListState , flingBehavior = rememberSnapperFlingBehavior ( lazyListState = lazyListState , // We need to provide the unresolved end value, so use Ltr endContentPadding = contentPadding . calculateEndPadding ( LayoutDirection . Ltr ), ), contentPadding = contentPadding , ) { // content } LazyColumn val lazyListState = rememberLazyListState () val contentPadding = PaddingValues (...) LazyColumn ( state = lazyListState , flingBehavior = rememberSnapperFlingBehavior ( lazyListState = lazyListState , endContentPadding = contentPadding . calculateBottomPadding (), ), contentPadding = contentPadding , ) { // content }","title":"Content padding"},{"location":"usage/#finding-the-current-item","text":"Most of the time apps will probably use the short-hand convenience function: rememberSnapperFlingBehavior(LazyListState) , but there are times when it is useful to get access to the SnapperLayoutInfo . SnapperLayoutInfo provides lots of information about the 'snapping state' of the scrollable container, and provides access to the 'current item'. For example, if you wish to invoke some action when a fling + snap has finished you can do the following: val lazyListState = rememberLazyListState () val layoutInfo = rememberLazyListSnapperLayoutInfo ( lazyListState ) LaunchedEffect ( lazyListState . isScrollInProgress ) { if ( ! lazyListState . isScrollInProgress ) { // The scroll (fling) has finished, get the current item and // do something with it! val snappedItem = layoutInfo . currentItem // TODO: do something with snappedItem } } LazyColumn ( state = lazyListState , flingBehavior = rememberSnapperFlingBehavior ( layoutInfo ), ) { // content }","title":"Finding the 'current' item"},{"location":"usage/#controlling-the-maximum-fling-distance","text":"The maximumFlingDistance parameter allows customization of the maximum distance that a user can fling (and snap to). Apps can provide a block which will be called once a fling has been started. The block is given the SnapperLayoutInfo , if it needs to use the layout to determine the distance. The following example sets the maximum fling distance to 3x the container width. LazyRow ( state = lazyListState , flingBehavior = rememberSnapperFlingBehavior ( lazyListState = lazyListState , maximumFlingDistance = { layoutInfo -> val scrollLength = layoutInfo . endScrollOffset - layoutInfo . startScrollOffset // Allow the user to scroll 3x the LazyRow 'width' scrollLength * 3f } ), ) { // content }","title":"Controlling the maximum fling distance"},{"location":"usage/#animation-specs","text":"SnapperFlingBehavior allows setting of two different animation specs: decayAnimationSpec and springAnimationSpec . decayAnimationSpec is the main spec used for flinging, and is used when the fling has enough velocity to scroll past the current item. springAnimationSpec is used when there is not enough velocity to fling using decayAnimationSpec , and instead 'snaps' to the current item. Both of the specs can be customized to apps wishes.","title":"Animation specs"},{"location":"using-snapshot-version/","text":"Using a Snapshot Version of the Library \u00b6 If you would like to depend on the cutting edge version of the Snapper library, you can use the snapshot versions that are published to Sonatype OSSRH 's snapshot repository. These are updated on every commit to main . To do so: repositories { // ... maven { url 'https://oss.sonatype.org/content/repositories/snapshots' } } dependencies { // Check the latest SNAPSHOT version from the link above classpath 'dev.chrisbanes.snapper:snapper:XXX-SNAPSHOT' } You might see a number of different versioned snapshots. If we use an example: 0.3.0-SNAPSHOT is a build from the main branch, and depends on the latest tagged Jetpack Compose release (i.e. alpha03 ). 0.3.0.compose-6574163-SNAPSHOT is a build from the snapshot branch. This depends on the SNAPSHOT build of Jetpack Compose from build 6574163 . You should only use these if you are using Jetpack Compose snapshot versions (see below). Using Jetpack Compose Snapshots \u00b6 If you're using SNAPSHOT versions of the androidx.compose libraries, you might run into issues with the current stable release forcing an older version of those libraries. We publish snapshot versions of the library which depend on recent Jetpack Compose SNAPSHOT repositories. To find a recent build, look through the snapshot repository for any versions in the scheme x.x.x.compose-YYYY-SNAPSHOT (for example: 0.3.0.compose-6574163-SNAPSHOT ). The YYYY in the scheme is the snapshot build being used from AndroidX (from the example: build 6574163 ). You can then use it like so: repositories { // ... maven { url 'https://oss.sonatype.org/content/repositories/snapshots' } } dependencies { // Check the latest SNAPSHOT version from the link above classpath 'dev.chrisbanes.snapper:snapper:XXXX.compose-YYYYY-SNAPSHOT' } These builds are updated regularly, but there's no guarantee that we will create one for a given snapshot number. Note: you might also see versions in the scheme x.x.x.ui-YYYY-SNAPSHOT . These are the same, just using an older suffix.","title":"Using a Snapshot Version of the Library"},{"location":"using-snapshot-version/#using-a-snapshot-version-of-the-library","text":"If you would like to depend on the cutting edge version of the Snapper library, you can use the snapshot versions that are published to Sonatype OSSRH 's snapshot repository. These are updated on every commit to main . To do so: repositories { // ... maven { url 'https://oss.sonatype.org/content/repositories/snapshots' } } dependencies { // Check the latest SNAPSHOT version from the link above classpath 'dev.chrisbanes.snapper:snapper:XXX-SNAPSHOT' } You might see a number of different versioned snapshots. If we use an example: 0.3.0-SNAPSHOT is a build from the main branch, and depends on the latest tagged Jetpack Compose release (i.e. alpha03 ). 0.3.0.compose-6574163-SNAPSHOT is a build from the snapshot branch. This depends on the SNAPSHOT build of Jetpack Compose from build 6574163 . You should only use these if you are using Jetpack Compose snapshot versions (see below).","title":"Using a Snapshot Version of the Library"},{"location":"using-snapshot-version/#using-jetpack-compose-snapshots","text":"If you're using SNAPSHOT versions of the androidx.compose libraries, you might run into issues with the current stable release forcing an older version of those libraries. We publish snapshot versions of the library which depend on recent Jetpack Compose SNAPSHOT repositories. To find a recent build, look through the snapshot repository for any versions in the scheme x.x.x.compose-YYYY-SNAPSHOT (for example: 0.3.0.compose-6574163-SNAPSHOT ). The YYYY in the scheme is the snapshot build being used from AndroidX (from the example: build 6574163 ). You can then use it like so: repositories { // ... maven { url 'https://oss.sonatype.org/content/repositories/snapshots' } } dependencies { // Check the latest SNAPSHOT version from the link above classpath 'dev.chrisbanes.snapper:snapper:XXXX.compose-YYYYY-SNAPSHOT' } These builds are updated regularly, but there's no guarantee that we will create one for a given snapshot number. Note: you might also see versions in the scheme x.x.x.ui-YYYY-SNAPSHOT . These are the same, just using an older suffix.","title":"Using Jetpack Compose Snapshots"}]}